from ecdsa import SigningKey, NIST224p
from ecdsa.util import sigencode_string, sigdecode_string
from ecdsa.numbertheory import inverse_mod
from hashlib import sha1
if __name__ == "__main__":
    #Messages to be signed
    message_1 = str("message_1")
    message_2 = str("message_2")

    #Generates the private key using the NIST224p curve, and SHA-1 hash function
    sk = SigningKey.generate(curve=NIST224p)

    #This is the secret number used to sign messages
    privateKey = sk.privkey.secret_multiplier

    #gets the public key (vk) 
    vk = sk.get_verifying_key()

    #Signing a message 
    signature = sk.sign(message_1.encode('utf-8'),k=22)
    

    #Pulling out the Signature Pair
    r1, s1 = sigdecode_string(signature, vk.pubkey.order)
    
    #Singing a second message using the same K value, using the same K value is what opens ECDSA to attack 
    signature2 = sk.sign(message_2.encode("utf-8"),k=22)

    #Pulling out the second Signature Pair (Note: r1 == r2 due to the K value being the same)
    r2, s2 = sigdecode_string(signature2, vk.pubkey.order)

    #Start the attack
    #Get the integer representation of the hashed messages 
    L1 = int(sha1(message_1.encode('utf-8')).hexdigest(), 16)
    L2 = int(sha1(message_2.encode('utf-8')).hexdigest(), 16)

    #A bit of Math 
    #L1 = Hash(message_1) 
    #L2 = Hash(message_2)
    #pk = Private Key (unknown to attacker)
    #R  = r1 == r2
    #K = K value that was used (unknown to attacker)
    #N = integer order of G (part of Public Key)
    
    #         From Signing Defintion
    #s1 = (L1 + pk * R) / K Mod N    and     s2 = (L2 + pk * R) / K Mod N
    
    #         Rearrange 
    #K = (L1 + pk * R) / s1 Mod N    and     K = (L2 + pk * R) / s2 Mod N
    
    #         Set Equal
    #(L1 + pk * R) / s1 = (L2 + pk * R) / s2     Mod N
    
    #         Solve for pk (private key)
    #pk Mod N = (s2 * L1 - s1 * L2) / R * (s1 - s2)

    privateKeyPrediction = ((((s2 * L1) % vk.pubkey.order) - ((s1 * L2) % vk.pubkey.order)) * inverse_mod(r1 * ((s1 - s2) % vk.pubkey.order), vk.pubkey.order)) % vk.pubkey.order

    
    #By compairing the actual secret key with prediction we can prove that we have just solved for the private key
    print(privateKey)
    print(privateKeyPrediction)






